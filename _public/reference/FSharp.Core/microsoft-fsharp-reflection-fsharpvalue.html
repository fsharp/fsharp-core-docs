<html class="js csstransforms3d">
  <head>
    <meta charSet="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>
      F# Core API Docs | FSharpValue
    </title>
    <link rel="icon" type="image/png" sizes="32x32" href="http://localhost:8080//static/images/favicon.png"/>
    <link rel="stylesheet" href="http://localhost:8080//static/css/nucleus.css"/>
    <link rel="stylesheet" href="http://localhost:8080//static/css/fontawesome-all.min.css"/>
    <link rel="stylesheet" href="http://localhost:8080//static/css/hybrid.css"/>
    <link rel="stylesheet" href="http://localhost:8080//static/css/featherlight.min.css"/>
    <link rel="stylesheet" href="http://localhost:8080//static/css/perfect-scrollbar.min.css"/>
    <link rel="stylesheet" href="http://localhost:8080//static/css/auto-complete.css"/>
    <link rel="stylesheet" href="http://localhost:8080//static/css/atom-one-dark-reasonable.css"/>
    <link rel="stylesheet" href="http://localhost:8080//static/css/theme.css"/>
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.0/styles/atom-one-dark.min.css"/>
    <link rel="stylesheet" href="http://localhost:8080//static/css/theme-green.css"/>
    <script src="http://localhost:8080//static/js/jquery-3.3.1.min.js"></script>
  </head>
  <body>
    <nav id="sidebar">
      <div id="header-wrapper">
        <div id="header">
          <h2 id="logo">
            F# Core API Docs
          </h2>
        </div>
        <div class="searchbox">
          <label for="search-by">
            <i class="fas fa-search"></i>
          </label>
          <input data-search-input="" id="search-by" type="search" placeholder="Search..."/>
          <span data-search-clear="">
            <i class="fas fa-times"></i>
          </span>
        </div>
        <script type="text/javascript" src="http://localhost:8080//static/js/lunr.min.js"></script>
        <script type="text/javascript" src="http://localhost:8080//static/js/auto-complete.js"></script>
        <script type="text/javascript">
          var baseurl ='http://localhost:8080/'
        </script>
        <script type="text/javascript" src="http://localhost:8080//static/js/search.js"></script>
        <script src="http://localhost:8080//static/js/highlight.pack.js"></script>
        <script>
          hljs.initHighlightingOnLoad();
        </script>
      </div>
      <div class="highlightable">
        <ul class="topics">
          <li id="menu-refs" class="dd-item menu-group-link menu-group-link-active">
            <a>
              API References
            </a>
          </li>
        </ul>
        <ul id="submenu-refs" class="submenu submenu-active">
          <li>
            <a href="http://localhost:8080//reference/FSharp.Core/index.html" class="padding">
              FSharp.Core
            </a>
          </li>
        </ul>
        <section id="shortcuts">
          <h3>
            Shortucts
          </h3>
          <ul>
            <li>
              <a class="padding" href="/">
                <i class="fas fa-home"></i>
                Home
              </a>
            </li>
            <li>
              <a class="padding" href="http://fsharp.org">
                <i class="fas fa-cubes"></i>
                F# Software Foundation
              </a>
            </li>
            <li>
              <a class="padding" href="https://github.com/dotnet/fsharp">
                <i class="fab fa-github"></i>
                GitHub repo
              </a>
            </li>
          </ul>
        </section>
        <section id="footer">
          <p>Built with <a href="https://github.com/ionide/Fornax">Fornax</a>
        </section>
      </div>
    </nav>
    <section id="body">
      <div id="overlay"></div>
      <div class="padding highlightable">
        <div id="body-inner">
          <span id="sidebar-toggle-span">
            <a href="#" id="sidebar-toggle" data-sidebar-toggle="">
              <i class="fas fa-bars"></i>
               navigation
            </a>
          </span>
          <div class="api-page">
            <h2>
              FSharpValue
            </h2>
            <b>
              Namespace: 
            </b>
            <a href="Microsoft.FSharp.Reflection.html">
              Microsoft.FSharp.Reflection
            </a>
            <br/>
            <b>
              Parent: 
            </b>
            <a href="Microsoft.FSharp.Reflection.html">
              Microsoft.FSharp.Reflection
            </a>
            <span>
              <div class="comment"></br><p class='summary'>Contains operations associated with constructing and analyzing values associated with F# types
 such as records, unions and tuples.</p></div>
            </span>
            <br/>
            <b>
              Attributes:
            </b>
            <br/>
            <code>
              AbstractClassAttribute
            </code>
            <br/>
            <code>
              SealedAttribute
            </code>
            <br/>
            <table>
              <tr>
                <th width="35%">
                  Name
                </th>
                <th width="65%">
                  Description
                </th>
              </tr>
              <tr>
                <td colSpan="3">
                  <b>
                    Static Members
                  </b>
                </td>
              </tr>
              <tr>
                <td>
                  <code>
                    GetExceptionFields
                  </code>
                  <br/>
                  <br/>
                  <b>
                    Signature: 
                  </b>
                  (exn:obj * bindingFlags:BindingFlags option) -> obj []
                  <br/>
                </td>
                <td>
                  <div class="comment"></br><p class='summary'>Reads all the fields from a value built using an instance of an F# exception declaration</p><h2>Parameters</h2><dl><dt><span class='parameter'>exn</span></dt><dd><p>The exception instance.</p></dd><dt><span class='parameter'>bindingFlags</span></dt><dd><p>Optional binding flags.</p></dd></dl><p class='returns'>Returns: The fields from the given exception.</p><h2>Remarks</h2><p class='remarks'>Assumes the given input is an F# exception value. If not, ArgumentException is raised.</p></div>
                </td>
              </tr>
              <tr>
                <td>
                  <code>
                    GetRecordField
                  </code>
                  <br/>
                  <br/>
                  <b>
                    Signature: 
                  </b>
                  (record:obj * info:PropertyInfo) -> obj
                  <br/>
                </td>
                <td>
                  <div class="comment"></br><p class='summary'>Reads a field from a record value.</p><h2>Parameters</h2><dl><dt><span class='parameter'>record</span></dt><dd><p>The record object.</p></dd><dt><span class='parameter'>info</span></dt><dd><p>The PropertyInfo describing the field to read.</p></dd></dl><p class='returns'>Returns: The field from the record.</p><h2>Remarks</h2><p class='remarks'>Assumes the given input is a record value. If not, ArgumentException is raised.</p></div>
                </td>
              </tr>
              <tr>
                <td>
                  <code>
                    GetRecordFields
                  </code>
                  <br/>
                  <br/>
                  <b>
                    Signature: 
                  </b>
                  (record:obj * bindingFlags:BindingFlags option) -> obj []
                  <br/>
                </td>
                <td>
                  <div class="comment"></br><p class='summary'>Reads all the fields from a record value.</p><h2>Parameters</h2><dl><dt><span class='parameter'>record</span></dt><dd><p>The record object.</p></dd><dt><span class='parameter'>bindingFlags</span></dt><dd><p>Optional binding flags for the record.</p></dd></dl><p class='returns'>Returns: The array of fields from the record.</p><h2>Remarks</h2><p class='remarks'>Assumes the given input is a record value. If not, ArgumentException is raised.</p></div>
                </td>
              </tr>
              <tr>
                <td>
                  <code>
                    GetTupleField
                  </code>
                  <br/>
                  <br/>
                  <b>
                    Signature: 
                  </b>
                  (tuple:obj * index:int) -> obj
                  <br/>
                </td>
                <td>
                  <div class="comment"></br><p class='summary'>Reads a field from a tuple value.</p><h2>Parameters</h2><dl><dt><span class='parameter'>tuple</span></dt><dd><p>The input tuple.</p></dd><dt><span class='parameter'>index</span></dt><dd><p>The index of the field to read.</p></dd></dl><p class='returns'>Returns: The value of the field.</p><h2>Remarks</h2><p class='remarks'>Assumes the given input is a tuple value. If not, ArgumentException is raised.</p></div>
                </td>
              </tr>
              <tr>
                <td>
                  <code>
                    GetTupleFields
                  </code>
                  <br/>
                  <br/>
                  <b>
                    Signature: 
                  </b>
                  tuple:obj -> obj []
                  <br/>
                </td>
                <td>
                  <div class="comment"></br><p class='summary'>Reads all fields from a tuple.</p><h2>Parameters</h2><dl><dt><span class='parameter'>tuple</span></dt><dd><p>The input tuple.</p></dd></dl><p class='returns'>Returns: An array of the fields from the given tuple.</p><h2>Remarks</h2><p class='remarks'>Assumes the given input is a tuple value. If not, ArgumentException is raised.</p></div>
                </td>
              </tr>
              <tr>
                <td>
                  <code>
                    GetUnionFields
                  </code>
                  <br/>
                  <br/>
                  <b>
                    Signature: 
                  </b>
                  (value:obj * unionType:Type * bindingFlags:BindingFlags option) -> UnionCaseInfo * obj []
                  <br/>
                </td>
                <td>
                  <div class="comment"></br><p class='summary'>Identify the union case and its fields for an object</p><h2>Parameters</h2><dl><dt><span class='parameter'>value</span></dt><dd><p>The input union case.</p></dd><dt><span class='parameter'>unionType</span></dt><dd><p>The union type containing the value.</p></dd><dt><span class='parameter'>bindingFlags</span></dt><dd><p>Optional binding flags.</p></dd></dl><p class='returns'>Returns: The description of the union case and its fields.</p><h2>Remarks</h2><p class='remarks'>Assumes the given input is a union case value. If not, ArgumentException is raised.

 If the type is not given, then the runtime type of the input object is used to identify the
 relevant union type. The type should always be given if the input object may be null. For example, 
 option values may be represented using the 'null'.</p></div>
                </td>
              </tr>
              <tr>
                <td>
                  <code>
                    MakeFunction
                  </code>
                  <br/>
                  <br/>
                  <b>
                    Signature: 
                  </b>
                  (functionType:Type * implementation:(obj -> obj)) -> obj
                  <br/>
                </td>
                <td>
                  <div class="comment"></br><p class='summary'>Builds a typed function from object from a dynamic function implementation</p><h2>Parameters</h2><dl><dt><span class='parameter'>functionType</span></dt><dd><p>The function type of the implementation.</p></dd><dt><span class='parameter'>implementation</span></dt><dd><p>The untyped lambda of the function implementation.</p></dd></dl><p class='returns'>Returns: A typed function from the given dynamic implementation.</p></div>
                </td>
              </tr>
              <tr>
                <td>
                  <code>
                    MakeRecord
                  </code>
                  <br/>
                  <br/>
                  <b>
                    Signature: 
                  </b>
                  (recordType:Type * values:obj [] * bindingFlags:BindingFlags option) -> obj
                  <br/>
                </td>
                <td>
                  <div class="comment"></br><p class='summary'>Creates an instance of a record type.</p><h2>Parameters</h2><dl><dt><span class='parameter'>recordType</span></dt><dd><p>The type of record to make.</p></dd><dt><span class='parameter'>values</span></dt><dd><p>The array of values to initialize the record.</p></dd><dt><span class='parameter'>bindingFlags</span></dt><dd><p>Optional binding flags for the record.</p></dd></dl><p class='returns'>Returns: The created record.</p><h2>Remarks</h2><p class='remarks'>Assumes the given input is a record type.</p></div>
                </td>
              </tr>
              <tr>
                <td>
                  <code>
                    MakeTuple
                  </code>
                  <br/>
                  <br/>
                  <b>
                    Signature: 
                  </b>
                  (tupleElements:obj [] * tupleType:Type) -> obj
                  <br/>
                </td>
                <td>
                  <div class="comment"></br><p class='summary'>Creates an instance of a tuple type</p><h2>Parameters</h2><dl><dt><span class='parameter'>tupleElements</span></dt><dd><p>The array of tuple fields.</p></dd><dt><span class='parameter'>tupleType</span></dt><dd><p>The tuple type to create.</p></dd></dl><p class='returns'>Returns: An instance of the tuple type with the given elements.</p><h2>Remarks</h2><p class='remarks'>Assumes at least one element is given. If not, ArgumentException is raised.</p></div>
                </td>
              </tr>
              <tr>
                <td>
                  <code>
                    MakeUnion
                  </code>
                  <br/>
                  <br/>
                  <b>
                    Signature: 
                  </b>
                  (unionCase:UnionCaseInfo * args:obj [] * bindingFlags:BindingFlags option) -> obj
                  <br/>
                </td>
                <td>
                  <div class="comment"></br><p class='summary'>Create a union case value.</p><h2>Parameters</h2><dl><dt><span class='parameter'>unionCase</span></dt><dd><p>The description of the union case to create.</p></dd><dt><span class='parameter'>args</span></dt><dd><p>The array of arguments to construct the given case.</p></dd><dt><span class='parameter'>bindingFlags</span></dt><dd><p>Optional binding flags.</p></dd></dl><p class='returns'>Returns: The constructed union case.</p></div>
                </td>
              </tr>
              <tr>
                <td>
                  <code>
                    PreComputeRecordConstructor
                  </code>
                  <br/>
                  <br/>
                  <b>
                    Signature: 
                  </b>
                  (recordType:Type * bindingFlags:BindingFlags option) -> obj [] -> obj
                  <br/>
                </td>
                <td>
                  <div class="comment"></br><p class='summary'>Precompute a function for constructing a record value. </p><h2>Parameters</h2><dl><dt><span class='parameter'>recordType</span></dt><dd><p>The type of record to construct.</p></dd><dt><span class='parameter'>bindingFlags</span></dt><dd><p>Optional binding flags.</p></dd></dl><p class='returns'>Returns: A function to construct records of the given type.</p><h2>Remarks</h2><p class='remarks'>Assumes the given type is a RecordType.
 If not, ArgumentException is raised during pre-computation.</p></div>
                </td>
              </tr>
              <tr>
                <td>
                  <code>
                    PreComputeRecordConstructorInfo
                  </code>
                  <br/>
                  <br/>
                  <b>
                    Signature: 
                  </b>
                  (recordType:Type * bindingFlags:BindingFlags option) -> ConstructorInfo
                  <br/>
                </td>
                <td>
                  <div class="comment"></br><p class='summary'>Get a ConstructorInfo for a record type</p><h2>Parameters</h2><dl><dt><span class='parameter'>recordType</span></dt><dd><p>The record type.</p></dd><dt><span class='parameter'>bindingFlags</span></dt><dd><p>Optional binding flags.</p></dd></dl><p class='returns'>Returns: A ConstructorInfo for the given record type.</p></div>
                </td>
              </tr>
              <tr>
                <td>
                  <code>
                    PreComputeRecordFieldReader
                  </code>
                  <br/>
                  <br/>
                  <b>
                    Signature: 
                  </b>
                  info:PropertyInfo -> obj -> obj
                  <br/>
                </td>
                <td>
                  <div class="comment"></br><p class='summary'>Precompute a function for reading a particular field from a record.
 Assumes the given type is a RecordType with a field of the given name. 
 If not, ArgumentException is raised during pre-computation.</p><h2>Parameters</h2><dl><dt><span class='parameter'>info</span></dt><dd><p>The PropertyInfo of the field to read.</p></dd></dl><p class='returns'>Returns: A function to read the specified field from the record.</p><h2>Remarks</h2><p class='remarks'>Using the computed function will typically be faster than executing a corresponding call to Value.GetInfo
 because the path executed by the computed function is optimized given the knowledge that it will be
 used to read values of the given type.</p></div>
                </td>
              </tr>
              <tr>
                <td>
                  <code>
                    PreComputeRecordReader
                  </code>
                  <br/>
                  <br/>
                  <b>
                    Signature: 
                  </b>
                  (recordType:Type * bindingFlags:BindingFlags option) -> obj -> obj []
                  <br/>
                </td>
                <td>
                  <div class="comment"></br><p class='summary'>Precompute a function for reading all the fields from a record. The fields are returned in the
 same order as the fields reported by a call to Microsoft.FSharp.Reflection.Type.GetInfo for
 this type.</p><h2>Parameters</h2><dl><dt><span class='parameter'>recordType</span></dt><dd><p>The type of record to read.</p></dd><dt><span class='parameter'>bindingFlags</span></dt><dd><p>Optional binding flags.</p></dd></dl><p class='returns'>Returns: An optimized reader for the given record type.</p><h2>Remarks</h2><p class='remarks'>Assumes the given type is a RecordType. 
 If not, ArgumentException is raised during pre-computation.

 Using the computed function will typically be faster than executing a corresponding call to Value.GetInfo
 because the path executed by the computed function is optimized given the knowledge that it will be
 used to read values of the given type.</p></div>
                </td>
              </tr>
              <tr>
                <td>
                  <code>
                    PreComputeTupleConstructor
                  </code>
                  <br/>
                  <br/>
                  <b>
                    Signature: 
                  </b>
                  tupleType:Type -> obj [] -> obj
                  <br/>
                </td>
                <td>
                  <div class="comment"></br><p class='summary'>Precompute a function for reading the values of a particular tuple type</p><h2>Parameters</h2><dl><dt><span class='parameter'>tupleType</span></dt><dd><p>The type of tuple to read.</p></dd></dl><p class='returns'>Returns: A function to read a particular tuple type.</p><h2>Remarks</h2><p class='remarks'>Assumes the given type is a TupleType.
 If not, ArgumentException is raised during pre-computation.</p></div>
                </td>
              </tr>
              <tr>
                <td>
                  <code>
                    PreComputeTupleConstructorInfo
                  </code>
                  <br/>
                  <br/>
                  <b>
                    Signature: 
                  </b>
                  tupleType:Type -> ConstructorInfo * Type option
                  <br/>
                </td>
                <td>
                  <div class="comment"></br><p class='summary'>Gets a method that constructs objects of the given tuple type. 
 For small tuples, no additional type will be returned.</p><h2>Parameters</h2><dl><dt><span class='parameter'>tupleType</span></dt><dd><p>The input tuple type.</p></dd></dl><p class='returns'>Returns: The description of the tuple type constructor and an optional extra type
 for large tuples.</p><h2>Remarks</h2><p class='remarks'>For large tuples, an additional type is returned indicating that
 a nested encoding has been used for the tuple type. In this case
 the suffix portion of the tuple type has the given type and an
 object of this type must be created and passed as the last argument 
 to the ConstructorInfo. A recursive call to PreComputeTupleConstructorInfo 
 can be used to determine the constructor for that the suffix type.</p></div>
                </td>
              </tr>
              <tr>
                <td>
                  <code>
                    PreComputeTuplePropertyInfo
                  </code>
                  <br/>
                  <br/>
                  <b>
                    Signature: 
                  </b>
                  (tupleType:Type * index:int) -> PropertyInfo * (Type * int) option
                  <br/>
                </td>
                <td>
                  <div class="comment"></br><p class='summary'>Gets information that indicates how to read a field of a tuple</p><h2>Parameters</h2><dl><dt><span class='parameter'>tupleType</span></dt><dd><p>The input tuple type.</p></dd><dt><span class='parameter'>index</span></dt><dd><p>The index of the tuple element to describe.</p></dd></dl><p class='returns'>Returns: The description of the tuple element and an optional type and index if the tuple is big.</p></div>
                </td>
              </tr>
              <tr>
                <td>
                  <code>
                    PreComputeTupleReader
                  </code>
                  <br/>
                  <br/>
                  <b>
                    Signature: 
                  </b>
                  tupleType:Type -> obj -> obj []
                  <br/>
                </td>
                <td>
                  <div class="comment"></br><p class='summary'>Precompute a function for reading the values of a particular tuple type</p><h2>Parameters</h2><dl><dt><span class='parameter'>tupleType</span></dt><dd><p>The tuple type to read.</p></dd></dl><p class='returns'>Returns: A function to read values of the given tuple type.</p><h2>Remarks</h2><p class='remarks'>Assumes the given type is a TupleType.
 If not, ArgumentException is raised during pre-computation.</p></div>
                </td>
              </tr>
              <tr>
                <td>
                  <code>
                    PreComputeUnionConstructor
                  </code>
                  <br/>
                  <br/>
                  <b>
                    Signature: 
                  </b>
                  (unionCase:UnionCaseInfo * bindingFlags:BindingFlags option) -> obj [] -> obj
                  <br/>
                </td>
                <td>
                  <div class="comment"></br><p class='summary'>Precompute a function for constructing a discriminated union value for a particular union case. </p><h2>Parameters</h2><dl><dt><span class='parameter'>unionCase</span></dt><dd><p>The description of the union case.</p></dd><dt><span class='parameter'>bindingFlags</span></dt><dd><p>Optional binding flags.</p></dd></dl><p class='returns'>Returns: A function for constructing values of the given union case.</p></div>
                </td>
              </tr>
              <tr>
                <td>
                  <code>
                    PreComputeUnionConstructorInfo
                  </code>
                  <br/>
                  <br/>
                  <b>
                    Signature: 
                  </b>
                  (unionCase:UnionCaseInfo * bindingFlags:BindingFlags option) -> MethodInfo
                  <br/>
                </td>
                <td>
                  <div class="comment"></br><p class='summary'>A method that constructs objects of the given case</p><h2>Parameters</h2><dl><dt><span class='parameter'>unionCase</span></dt><dd><p>The description of the union case.</p></dd><dt><span class='parameter'>bindingFlags</span></dt><dd><p>Optional binding flags.</p></dd></dl><p class='returns'>Returns: The description of the constructor of the given union case.</p></div>
                </td>
              </tr>
              <tr>
                <td>
                  <code>
                    PreComputeUnionReader
                  </code>
                  <br/>
                  <br/>
                  <b>
                    Signature: 
                  </b>
                  (unionCase:UnionCaseInfo * bindingFlags:BindingFlags option) -> obj -> obj []
                  <br/>
                </td>
                <td>
                  <div class="comment"></br><p class='summary'>Precompute a function for reading all the fields for a particular discriminator case of a union type</p><h2>Parameters</h2><dl><dt><span class='parameter'>unionCase</span></dt><dd><p>The description of the union case to read.</p></dd><dt><span class='parameter'>bindingFlags</span></dt><dd><p>Optional binding flags.</p></dd></dl><p class='returns'>Returns: A function to for reading the fields of the given union case.</p><h2>Remarks</h2><p class='remarks'>Using the computed function will typically be faster than executing a corresponding call to GetFields</p></div>
                </td>
              </tr>
              <tr>
                <td>
                  <code>
                    PreComputeUnionTagMemberInfo
                  </code>
                  <br/>
                  <br/>
                  <b>
                    Signature: 
                  </b>
                  (unionType:Type * bindingFlags:BindingFlags option) -> MemberInfo
                  <br/>
                </td>
                <td>
                  <div class="comment"></br><p class='summary'>Precompute a property or static method for reading an integer representing the case tag of a union type.</p><h2>Parameters</h2><dl><dt><span class='parameter'>unionType</span></dt><dd><p>The type of union to read.</p></dd><dt><span class='parameter'>bindingFlags</span></dt><dd><p>Optional binding flags.</p></dd></dl><p class='returns'>Returns: The description of the union case reader.</p></div>
                </td>
              </tr>
              <tr>
                <td>
                  <code>
                    PreComputeUnionTagReader
                  </code>
                  <br/>
                  <br/>
                  <b>
                    Signature: 
                  </b>
                  (unionType:Type * bindingFlags:BindingFlags option) -> obj -> int
                  <br/>
                </td>
                <td>
                  <div class="comment"></br><p class='summary'>Assumes the given type is a union type. 
 If not, ArgumentException is raised during pre-computation.</p><h2>Parameters</h2><dl><dt><span class='parameter'>unionType</span></dt><dd><p>The type of union to optimize reading.</p></dd><dt><span class='parameter'>bindingFlags</span></dt><dd><p>Optional binding flags.</p></dd></dl><p class='returns'>Returns: An optimized function to read the tags of the given union type.</p><h2>Remarks</h2><p class='remarks'>Using the computed function is more efficient than calling GetUnionCase
 because the path executed by the computed function is optimized given the knowledge that it will be
 used to read values of the given type.</p></div>
                </td>
              </tr>
            </table>
          </div>
        </div>
      </div>
    </section>
    <div style="left: -1000px; overflow: scroll; position: absolute; top: -1000px; border: none; box-sizing: content-box; height: 200px; margin: 0px; padding: 0px; width: 200px;">
      <div style="border: none; box-sizing: content-box; height: 200px; margin: 0px; padding: 0px; width: 200px;"></div>
    </div>
    <script src="http://localhost:8080//static/js/clipboard.min.js"></script>
    <script src="http://localhost:8080//static/js/perfect-scrollbar.min.js"></script>
    <script src="http://localhost:8080//static/js/perfect-scrollbar.jquery.min.js"></script>
    <script src="http://localhost:8080//static/js/jquery.sticky.js"></script>
    <script src="http://localhost:8080//static/js/featherlight.min.js"></script>
    <script src="http://localhost:8080//static/js/modernizr.custom-3.6.0.js"></script>
    <script src="http://localhost:8080//static/js/learn.js"></script>
    <script src="http://localhost:8080//static/js/hugo-learn.js"></script>
    <link rel="stylesheet" href="http://localhost:8080//static/mermaid/mermaid.css"/>
    <script src="http://localhost:8080//static/mermaid/mermaid.js"></script>
    <script>
      mermaid.initialize({ startOnLoad: true });
    </script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.0/languages/fsharp.min.js"></script>
    <script>
      hljs.initHighlightingOnLoad()
    </script>
  </body>
</html>